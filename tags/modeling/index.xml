<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Modeling on μβ</title>
    <link>https://matbesancon.github.io/tags/modeling/</link>
    <description>Recent content in Modeling on μβ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Mathieu Besançon</copyright>
    <lastBuildDate>Wed, 30 May 2018 00:00:00 +0200</lastBuildDate>
    
	<atom:link href="https://matbesancon.github.io/tags/modeling/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>The cutting stock problem: part 2, solving with column generation</title>
      <link>https://matbesancon.github.io/post/2018-05-25-colgen2/</link>
      <pubDate>Wed, 30 May 2018 00:00:00 +0200</pubDate>
      
      <guid>https://matbesancon.github.io/post/2018-05-25-colgen2/</guid>
      <description>In the previous post, we explored a well-known integer optimization situation in manufacturing, the cutting stock problem. After some details on the decisions, constraints and objectives, we implemented a naive model in JuMP.
One key thing to notice is the explosion of number of variables and constraints and the fact that relaxed solutions (without constraining variables to be integers) are very far from actual feasible solutions.
We will now use an other way of formulating the problem, using a problem decomposition and an associated solution method (column generation).</description>
    </item>
    
    <item>
      <title>Tackling the cutting stock problem: part 1, problem exploration</title>
      <link>https://matbesancon.github.io/post/2018-05-23-colgen/</link>
      <pubDate>Wed, 23 May 2018 00:00:00 +0200</pubDate>
      
      <guid>https://matbesancon.github.io/post/2018-05-23-colgen/</guid>
      <description>Integer optimization often feels weird (at least to me). Simple reformulations of a (mixed) integer optimization problem (MIP) can make it way easier to solve. We&amp;rsquo;re going to explore one well-known example of such integer problem in two blog posts. This first part introduces the problem and develops a naive solution. We&amp;rsquo;re going to see why it&amp;rsquo;s complex to solve and why this formulation does not scale.
In a second post, we will see a reformulation of the problem which makes it easier to solve and scales to bigger instances.</description>
    </item>
    
    <item>
      <title>DifferentialEquations.jl - part 2: decision from the model</title>
      <link>https://matbesancon.github.io/post/2017-12-20-diffeq-julia2/</link>
      <pubDate>Wed, 20 Dec 2017 00:00:00 +0100</pubDate>
      
      <guid>https://matbesancon.github.io/post/2017-12-20-diffeq-julia2/</guid>
      <description>In the last article, we explored different modeling options for a three-component systems which could represent the dynamics of a chemical reaction or a disease propagation in a population. Building on top of this model, we will formulate a desirable outcome and find a decision which maximizes this outcome.
 In addition to the packages imported in the last post, we will also use BlackBoxOptim.jl:
 import DifferentialEquations const DiffEq = DifferentialEquations import Plots import Optim The model The same chemical system with three components, A, B and R will be used: $$A + B → 2B$$ $$B → R$$</description>
    </item>
    
    <item>
      <title>Getting started with DifferentialEquations.jl</title>
      <link>https://matbesancon.github.io/post/2017-12-14-diffeq-julia/</link>
      <pubDate>Thu, 14 Dec 2017 00:00:00 +0100</pubDate>
      
      <guid>https://matbesancon.github.io/post/2017-12-14-diffeq-julia/</guid>
      <description>DifferentialEquations.jl came to be a key component of Julia&amp;rsquo;s scientific ecosystem. After checking the JuliaCon talk of its creator, I couldn&amp;rsquo;t wait to start building stuff with it, so I created and developed a simple example detailed in this blog post. Starting from a basic ordinary differential equation (ODE), we add noise, making it stochastic, and finally turn it into a discrete version.
 Before running the code below, two imports will be used:</description>
    </item>
    
  </channel>
</rss>