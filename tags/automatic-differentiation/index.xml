<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>automatic-differentiation on μβ</title>
    <link>https://matbesancon.github.io/tags/automatic-differentiation/</link>
    <description>Recent content in automatic-differentiation on μβ</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-ca</language>
    <copyright>&amp;copy; {year} Mathieu Besançon</copyright>
    <lastBuildDate>Wed, 23 Dec 2020 00:00:00 +0100</lastBuildDate>
    
	    <atom:link href="https://matbesancon.github.io/tags/automatic-differentiation/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Sets, chains and rules - part I</title>
      <link>https://matbesancon.github.io/post/2020-12-23-chains_sets/</link>
      <pubDate>Wed, 23 Dec 2020 00:00:00 +0100</pubDate>
      
      <guid>https://matbesancon.github.io/post/2020-12-23-chains_sets/</guid>
      <description>&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#mathoptinterface-and-the-motivation&#34;&gt;MathOptInterface and the motivation&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#examples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#set-projections&#34;&gt;Set projections&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#extensible-distances&#34;&gt;Extensible distances&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#bonus&#34;&gt;Bonus&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;p&gt;In this post, I will develop the process through which the
&lt;a href=&#34;https://github.com/matbesancon/MathOptSetDistances.jl&#34;&gt;MathOptSetDistances.jl&lt;/a&gt;
package has been created and evolved. In the second one, I will go over the differentiation part.&lt;/p&gt;
&lt;h1 id=&#34;mathoptinterface-and-the-motivation&#34;&gt;MathOptInterface and the motivation&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://jump.dev/MathOptInterface.jl/dev/&#34;&gt;MathOptInterface.jl&lt;/a&gt; or MOI
for short is a Julia package to unify &lt;em&gt;structured constrained&lt;/em&gt; optimization problems.
The abstract representation of problems MOI addresses is as follows:&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
\min_{x}\,\, &amp;amp; F(x) \\\\&lt;br&gt;
\text{s.t.}\,\, &amp;amp; G_k(x) \in \mathcal{S}_k \,\, \forall k \\\\&lt;br&gt;
&amp;amp; x \in \mathcal{X}.
\end{align}
$$&lt;/p&gt;
&lt;p&gt;$\mathcal{X}$ is the domain of the decision variables,
$F$ is the objective function, mapping values of the variables to the real line.
The constrained aspect comes from the constraints $G_k(x) \in \mathcal{S}_k$,
some mappings of the variables $G_k$ have to belong to a certain set $\mathcal{S}_k$.
See this &lt;a href=&#34;https://arxiv.org/abs/2002.03447&#34;&gt;recent paper&lt;/a&gt; on MOI for more information
on this representation.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;structured&lt;/strong&gt; aspect comes from the fact that a specific form of $F$, $G$
and $\mathcal{S}$ is known in advance by the modeller. In other words, MOI
does not deal with arbitrary unknown functions or black-box sets.
For such cases, other tools are more adapted.&lt;/p&gt;
&lt;p&gt;From a given problem in this representation, two operations can be of interest
within a solution algorithm or from a user perspective:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Given a value for $x$, evaluating a function $F(x)$ or $G(x)$,&lt;/li&gt;
&lt;li&gt;Given a value $v$ in the co-domain of $G_k$, asserting whether $v \in S_k$.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first point is addressed by the function &lt;code&gt;eval_variables&lt;/code&gt; in the &lt;code&gt;MOI.Utilities&lt;/code&gt; submodule
(&lt;a href=&#34;https://jump.dev/MathOptInterface.jl/v0.9/apireference/#MathOptInterface.Utilities.eval_variables&#34;&gt;documentation&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;The second point appears as simple (or at least it did to me) but is trickier.
What tolerance should be set?
Most solvers include a numerical tolerance on constraint violations, should this
be propagated from user choices, and how?&lt;/p&gt;
&lt;p&gt;The deceivingly simple feature ended up opening one of the
&lt;a href=&#34;https://github.com/jump-dev/MathOptInterface.jl/pull/1023&#34;&gt;longest discussions&lt;/a&gt;
in the MOI repository.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Fairly straightforward[&amp;hellip;]
Optimistic me, beginning of the PR, February 2020&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A more meaningful query for solvers is, given a value $v$, what is the
&lt;strong&gt;distance&lt;/strong&gt; from $v$ to the set $\mathcal{S}$:&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
(\text{δ(v, s)})\,\,\min_{v_p}\,\, &amp;amp; \text{dist}(v_p, v) \\\\&lt;br&gt;
\text{s.t.}\,\, &amp;amp; v_p \in \mathcal{S} \\\\&lt;br&gt;
&amp;amp; v \in \mathcal{V}.
\end{align}
$$&lt;/p&gt;
&lt;p&gt;The optimal value of the problem above noted $δ(v, s)$ depends on the
notion of the distance taken between two values in the domain $\mathcal{V}$,
noted $dist(\cdot,\cdot)$ here.
In terms of implementation, the signature is roughly:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;distance_to_set(v&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;V, s&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;S) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Real&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;Aside:&lt;/em&gt;
this is an example where multiple dispatch brings great value to the design:
the implementation of &lt;code&gt;distance_to_set&lt;/code&gt; depends on both the value type &lt;code&gt;V&lt;/code&gt;
and the type of set &lt;code&gt;S&lt;/code&gt;. See why it&amp;rsquo;s useful [in the Bonus](# Bonus)&lt;/p&gt;
&lt;p&gt;If $\mathcal{S}$ was a generic set, computing this distance would be as hard as
solving an optimization problem with constraints $v \in \mathcal{S}$ but
since we are dealing with structured optimization, many particular sets have
closed-form solutions for the problem above.&lt;/p&gt;
&lt;h1 id=&#34;examples&#34;&gt;Examples&lt;/h1&gt;
&lt;p&gt;$\|\cdot\|$ will denote the $l_2-$norm if not specified.&lt;/p&gt;
&lt;p&gt;The distance computation problem defined by the following data:&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
&amp;amp; v \in \mathcal{V} = \mathbb{R}^n,\\&lt;br&gt;
&amp;amp; \mathcal{S} = \mathbb{Z}^n,\\&lt;br&gt;
&amp;amp; dist(a, b) = \|a - b\|
\end{align}
$$&lt;/p&gt;
&lt;p&gt;consists of rounding element-wise to the closest integer.&lt;/p&gt;
&lt;p&gt;The following data:&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
&amp;amp; v \in \mathcal{V} = \mathbb{R}^n,\\&lt;br&gt;
&amp;amp; \mathcal{S} = \mathbb{R}^n_+,\\&lt;br&gt;
&amp;amp; dist(a, b) = \|a - b\|
\end{align}
$$&lt;/p&gt;
&lt;p&gt;find the closest point in the positive orthant, with a result:&lt;/p&gt;
&lt;p&gt;$$
v_{p}\left[i\right] = \text{max}(v\left[i\right], 0) \,\, \forall i \in \{1..n\}.
$$&lt;/p&gt;
&lt;h1 id=&#34;set-projections&#34;&gt;Set projections&lt;/h1&gt;
&lt;p&gt;The distance from a point to a set tells us how far a given candidate is from
respecting a constraint. But for many algorithms, the quantity of interest is
the projection itself:&lt;/p&gt;
&lt;p&gt;$$
\Pi_{\mathcal{S}}(v) \equiv \text{arg}\min_v \delta(v, \mathcal{S}).
$$&lt;/p&gt;
&lt;p&gt;Like the optimal distance, the best projection onto a set can often be defined
in closed form i.e. without using generic optimization methods.&lt;/p&gt;
&lt;p&gt;We also keep the convention that the projection of a point already in the set is
always itself:
$$
δ(v, \mathcal{S}) = 0 \,\, \Leftrightarrow \,\, v \in \mathcal{S} \,\, \Leftrightarrow \,\, \Pi_{\mathcal{S}}(v) = v.
$$&lt;/p&gt;
&lt;p&gt;The interesting thing about projections is that once obtained, a distance
can be computed easily, although only computing the distance can be slightly
more efficient, since we do not need to allocate the projected point.&lt;/p&gt;
&lt;h1 id=&#34;extensible-distances&#34;&gt;Extensible distances&lt;/h1&gt;
&lt;p&gt;Imagine a set defined using two functions:
$$
\begin{align}
\mathcal{S} = \{v \in \mathcal{V}\,|\, f(v) \leq 0, g(v)\leq 0 \}.
\end{align}
$$&lt;/p&gt;
&lt;p&gt;The distance must be evaluated with respect to two values:
$$
(max(f(v), 0), max(g(v), 0)).
$$&lt;/p&gt;
&lt;p&gt;Here, the choice boils down to a norm, but hard-coding it seems harsh and rigid for users.
Even if we plan correctly and add most norms people would expect, someone will
end up with new exotic problems on &lt;a href=&#34;https://github.com/blegat/SetProg.jl&#34;&gt;sets&lt;/a&gt;,
&lt;a href=&#34;https://github.com/jump-dev/ComplexOptInterface.jl&#34;&gt;complex numbers&lt;/a&gt; or function spaces.&lt;/p&gt;
&lt;p&gt;The solution that came up after discussions is adding a type to dispatch on,
specifying the notion of distance used:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; distance_to_set(d&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;D, v&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;V, s&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;S)
        where {D &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;:&lt;/span&gt; AbstractDistance, V, S &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;:&lt;/span&gt; MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;AbstractSet}
    &lt;span style=&#34;color:#75715e&#34;&gt;# ...&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;which can for instance encode a p-norm or anything else.
In many cases, there is no ambiguity, and the package defines &lt;code&gt;DefaultDistance()&lt;/code&gt;
exactly for this.&lt;/p&gt;
&lt;h1 id=&#34;bonus&#34;&gt;Bonus&lt;/h1&gt;
&lt;p&gt;If you are coming from a class-based object-oriented background, a common
design choice is to define a &lt;code&gt;Set&lt;/code&gt; abstract class with a method &lt;code&gt;project_on_set(v::V)&lt;/code&gt; to implement.
This would work for most situations, since a set often implies a domain &lt;code&gt;V&lt;/code&gt;.
What about the following:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Projecting onto the reals (no-op)&lt;/span&gt;
project_on_set(v&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;AbstractVector&lt;/span&gt;{T}, s&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Reals) where {T &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Real&lt;/span&gt;}

&lt;span style=&#34;color:#75715e&#34;&gt;# Projecting onto the reals (actual work)&lt;/span&gt;
project_on_set(v&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;AbstractVector&lt;/span&gt;{T}, s&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Reals) where {T &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Complex&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Which &amp;ldquo;class&amp;rdquo; should own the implementation in that case?
From what I observed, libraries end up with either an enumeration:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; typeof(v) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AbstractVector&lt;/span&gt;{&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;:&lt;/span&gt;Reals}
    &lt;span style=&#34;color:#75715e&#34;&gt;# ...&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;elseif&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# ...&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;or when the number of possible domains is expected to be low, with several methods:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# in the set class Reals&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; project_real(v&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;AbstractVector&lt;/span&gt;{T}) where {T &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Real&lt;/span&gt;}
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; project_complex(v&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;AbstractVector&lt;/span&gt;{T}) where {T &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Complex&lt;/span&gt;}
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; project_scalar(v&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;T) where {T &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Real&lt;/span&gt;}
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As a last remark, one may wonder why would one define trivial sets as the &lt;code&gt;MOI.Reals&lt;/code&gt;
or the &lt;code&gt;MOI.Zeros&lt;/code&gt;. A good example where this is needed is the polyhedral cone:
$$
A x = 0
$$
with $x$ a vector. This makes more sense to define $Ax$ as the function and&lt;br&gt;
&lt;code&gt;MOI.Zeros&lt;/code&gt; as the set.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Differentiating the discrete: Automatic Differentiation meets Integer Optimization</title>
      <link>https://matbesancon.github.io/post/2020-01-23-discrete-diff/</link>
      <pubDate>Thu, 23 Jan 2020 00:00:00 +0100</pubDate>
      
      <guid>https://matbesancon.github.io/post/2020-01-23-discrete-diff/</guid>
      <description>&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;In continuous convex optimization, duality is often the theoretical foundation for
computing the sensibility of the optimal value of a problem to
one of its parameters. In the non-linear domain, it is fairly standard to assume
one can compute at any point of the domain the function $f(x)$ and gradient
$\nabla f(x)$.&lt;/p&gt;
&lt;p&gt;What about discrete optimization?&lt;br&gt;
The first thought would be that differentiating
the resolution of a discrete problem does not make sense, the information it yields
since infinitesimal variations in the domain of the variables do not make sense.&lt;/p&gt;
&lt;p&gt;However, three cases come to mind for which asking for gradients makes perfect sense:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;In mixed-integer linear problems, some variables take continuous values.
All linear expressions are differentiable, and every constraint coefficient,
right-hand-side and objective coefficient can have an attached partial derivative.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Even in pure-integer problems, the objective value will be a continuous
function of the coefficients, possibly locally smooth, for which one can get
the partial derivative associated with each weight.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We might be interested in computing the derivative of &lt;strong&gt;some&lt;/strong&gt; expression
of the variables with respect to some parameters, without this expression
being the objective.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For these points, some duality-based techniques and reformulations can be used,
sometimes very expensive when the input size grows.
One common approach is to first
solve the problem, then fixing the integer variables and re-solving the
continuous part of the problem to compute the dual values associated with
each constraint, and the reduced cost coefficients.
This leads to solving a NP-hard problem, followed by a second solution from
scratch of a linear optimization problem, still, it somehow works.&lt;/p&gt;
&lt;p&gt;More than just solving the model and computing results, one major use case
is embarking the result of an optimization problem into another more complete
program. The tricks developed above cannot be integrated with an automated way
of computing derivatives.&lt;/p&gt;
&lt;h1 id=&#34;automatic-differentiation&#34;&gt;Automatic Differentiation&lt;/h1&gt;
&lt;p&gt;Automatic Differentiation is far from new, but has known a gain in attention
in the last decade with its used in ML, increasing the usability of the available
libraries. It consists in getting an augmented information out of a function.&lt;/p&gt;
&lt;p&gt;If a function has a type signature &lt;code&gt;f: a -&amp;gt; b&lt;/code&gt;, the goal is, without modifying
the function, to compute a derivative, which is also a function, which to every
point in the domain, yields a linear map from domain to co-domain &lt;code&gt;df: a -&amp;gt; (a -o b)&lt;/code&gt;,
where &lt;code&gt;a -o b&lt;/code&gt; denotes a linear map, regardless of underlying representation (matrix, function, &amp;hellip;).
See the talk and paper&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; for a type-based formalism of AD if you are ok with programming language formalism.&lt;/p&gt;
&lt;h2 id=&#34;automatic-differentiation-on-a-pure-julia-solver&#34;&gt;Automatic differentiation on a pure-Julia solver&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Wikunia/ConstraintSolver.jl&#34;&gt;ConstraintSolver.jl&lt;/a&gt; is a recent
project by &lt;a href=&#34;https://github.com/Wikunia&#34;&gt;Wikunia&lt;/a&gt;. As the name indicates, it is a
&lt;a href=&#34;https://en.wikipedia.org/wiki/Constraint_programming&#34;&gt;constraint programming&lt;/a&gt;
solver, a more Computer-Science-flavoured approach to integer optimization.
As a Julia solver, it can leverage both multiple dispatch and the type system
to benefit from some features for free. One example of such
feature is automatic differentiation: if your function is generic enough
(not relying on a specific implementation of number types, such as &lt;code&gt;Float64&lt;/code&gt;),
gradients with respect to some parameters can be computed by calling the function
just once (forward-mode automatic differentiation).&lt;/p&gt;
&lt;h1 id=&#34;example-problem-weighted-independent-set&#34;&gt;Example problem: weighted independent set&lt;/h1&gt;
&lt;p&gt;Let us consider a classical problem in combinatorial optimization, given an undirected graph
$G = (V, E)$, finding a subset of the vertices, such that no two vertices in the
subset are connected by an edge, and that the total weight of the chosen vertices
is maximized.&lt;/p&gt;
&lt;h2 id=&#34;optimization-model-of-the-weighted-independent-set&#34;&gt;Optimization model of the weighted independent set&lt;/h2&gt;
&lt;p&gt;Formulated as an optimization problem, it looks as follows:&lt;/p&gt;
&lt;p&gt;$$\begin{align}
(\mathcal{P}): \max_{x} &amp;amp; \sum_{i \in V} w_i x_i \\\\&lt;br&gt;
\text{s.t.} \\\\&lt;br&gt;
&amp;amp; x_i + x_j \leq 1 \,\, \forall (i,j) \in E \\\\&lt;br&gt;
&amp;amp; x \in \mathbb{B}^{|V|}
\end{align}
$$&lt;/p&gt;
&lt;p&gt;Translated to English, this would be maximizing the weighted sum of picked
vertices, which are decisions living in the $|V|$-th dimensional binary space,
such that for each edge, no two vertices can be chosen.
The differentiable function here is the objective value of such optimization
problem, and the parameters we differentiate with respect to are the weights
attached to each vertex $w_i$. We will denote it $f(w) = \max_x (\mathcal{P}_w)$.&lt;/p&gt;
&lt;p&gt;If a vertex $i$ is not chosen in a solution, there are two cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the vertex has the same weight as at least one other, say $j$, such that
swapping $i$ and $j$ in the selected subset does not change the optimal value.
of $\mathcal{P}$.
In that case, there is a kink in the function, a discontinuity of the derivative,
which may not be computed correctly by automatic differentiation.
This is related to the phenomenon of degeneracy in the simplex algorithm,
multiple variables could be chosen equivalently to enter the base.&lt;/li&gt;
&lt;li&gt;there is no other vertex with the same weight, such that swapping the two
maintains the same objective value. In that case, the derivative is $0$,
small enough variations of the weight does not change the solution nor the objective.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If a vertex $i$ is chosen in a solution, then $x_i = 1$, and the corresponding
partial derivative of the weight is $\frac{\partial f(w)}{\partial w_i} = 1$.&lt;/p&gt;
&lt;h2 id=&#34;a-julia-implementation&#34;&gt;A Julia implementation&lt;/h2&gt;
&lt;p&gt;We will import a few packages, mostly MathOptInterface.jl (MOI), the foundation for
constrained optimization, the solver itself, the Test standard lib, and ForwardDiff.jl
for automatic differentiation.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Test
&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; ConstraintSolver
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; CS &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ConstraintSolver

&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; MathOptInterface
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; MOI &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; MathOptInterface

&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; ForwardDiff
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Let us first write an implementation for the max-weight independent set problem.
We will use a 4-vertex graph, looking as such:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://matbesancon.github.io/img/posts/diff_discrete/graph2.svg&#34; alt=&#34;Weighted graph&#34;&gt;&lt;/p&gt;
&lt;p&gt;The optimal answer here is to pick vertices 1 and 4 (in orange).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@testset&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Max independent set MOI&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
    matrix &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [
        &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
        &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
        &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    ]
    model &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; CS&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Optimizer()
    x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_constrained_variable(model, MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ZeroOne()) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, j &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; matrix[i,j] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; j
            (z, _) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_constrained_variable(model, MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;GreaterThan(&lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;))
            MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_constraint(model, z, MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;Integer&lt;/span&gt;())
            MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_constraint(model, z, MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;LessThan(&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;))
            f &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ScalarAffineFunction(
                [
                    MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ScalarAffineTerm(&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, x[i][&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]),
                    MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ScalarAffineTerm(&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, x[j][&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]),
                    MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ScalarAffineTerm(&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, z),
                ], &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;
            )
            MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_constraint(model, f, MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;EqualTo(&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;))
        &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
    weights &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;0.2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.1&lt;/span&gt;]
    terms &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ScalarAffineTerm(weights[i], x[i][&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; eachindex(x)]
    objective &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ScalarAffineFunction(terms, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;)
    MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;set(model, MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ObjectiveFunction{typeof(objective)}(), objective)
    MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;set(model, MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ObjectiveSense(), MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;MAX_SENSE)
    MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;optimize!(model)
    &lt;span style=&#34;color:#75715e&#34;&gt;# add some tests&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Why the additional code with&lt;code&gt;(z, _) = MOI.add_constrained_variable(model, MOI.GreaterThan(0.0))&lt;/code&gt;?
&lt;em&gt;ConstraintSolver.jl&lt;/em&gt; does not yet support constraints of the type &lt;code&gt;a x + b y &amp;lt;= c&lt;/code&gt;,
but linear equality constraints are fine, so we can derive equivalent formulations by adding a
slack variable &lt;code&gt;z&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For this problem, the tests could be on both the solution and objective value, as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@test&lt;/span&gt; MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(model, MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;VariablePrimal(), x[&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;@test&lt;/span&gt; MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(model, MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;VariablePrimal(), x[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;@test&lt;/span&gt; MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(model, MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ObjectiveValue()) ≈ &lt;span style=&#34;color:#ae81ff&#34;&gt;0.3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;An equivalent JuMP version would look look this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;matrix &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [
    &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
]
m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Model(with_optimizer(CS&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Optimizer))
x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@variable&lt;/span&gt;(m, x[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;], Bin)
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, j &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; matrix[i,j] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        zcomp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@variable&lt;/span&gt;(m)
        JuMP&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;set_binary(zcomp)
        &lt;span style=&#34;color:#a6e22e&#34;&gt;@constraint&lt;/span&gt;(m, x[i] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; x[j] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; zcomp &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
w &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;0.2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.1&lt;/span&gt;]
&lt;span style=&#34;color:#a6e22e&#34;&gt;@objective&lt;/span&gt;(m, Max, dot(w, x))
optimize!(m)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Why are we not using JuMP, which is much more concise and closer to the
mathematical formulation?&lt;/p&gt;
&lt;p&gt;JuMP uses &lt;code&gt;Float64&lt;/code&gt; for all value types, which means we do not get the benefit of
generic types, while &lt;code&gt;MathOptInterface&lt;/code&gt; types are parameterized by the numeric type used.
To be fair, maintaining type genericity on a project as large as JuMP
is hard without making performance compromises. JuMP is not built of functions, but
of a model object which contains a mutable state of the problem being constructed,
and building an Algebraic Modelling Language without this incremental build of the
model has not proved successful till now. One day, we may get a powerful declarative
DSL for mathematical optimization, but it has not come yet.&lt;/p&gt;
&lt;p&gt;Back to our problem, we now have a way to compute the optimal value and solution.
Let us implement our function $f(w)$:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; weighted_stable_set(w)
    matrix &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [
        &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
        &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
        &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    ]
    model &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; CS&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Optimizer(solution_type &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Real&lt;/span&gt;)
    x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_constrained_variable(model, MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ZeroOne()) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, j &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; matrix[i,j] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; j
            (z, _) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_constrained_variable(model, MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;GreaterThan(&lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;))
            MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_constraint(model, z, MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;Integer&lt;/span&gt;())
            MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_constraint(model, z, MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;LessThan(&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;))
            f &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ScalarAffineFunction(
                [
                    MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ScalarAffineTerm(&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, x[i][&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]),
                    MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ScalarAffineTerm(&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, x[j][&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]),
                    MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ScalarAffineTerm(&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, z),
                ], &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;
            )
            MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_constraint(model, f, MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;EqualTo(&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;))
        &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
    terms &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ScalarAffineTerm(w[i], x[i][&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; eachindex(x)]
    objective &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ScalarAffineFunction(terms, zero(eltype(w)))
    MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;set(model, MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ObjectiveFunction{typeof(objective)}(), objective)
    MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;set(model, MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ObjectiveSense(), MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;MAX_SENSE)
    MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;optimize!(model)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(model, MOI&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ObjectiveValue())
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We can now compute the gradient in one function call with ForwardDiff:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@testset&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Differentiating stable set&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
    weights &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;0.2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.1&lt;/span&gt;]
    ∇w &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ForwardDiff&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;gradient(weighted_stable_set, weights)
    &lt;span style=&#34;color:#a6e22e&#34;&gt;@test&lt;/span&gt; ∇w[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] ≈ &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;@test&lt;/span&gt; ∇w[&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;] ≈ &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;@test&lt;/span&gt; ∇w[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;] ≈ ∇w[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;] ≈ &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To understand how this derivative computation can work with just few
function calls (proportional to the size of the input), one must dig
a bit deeper in &lt;a href=&#34;https://en.wikipedia.org/wiki/Dual_number&#34;&gt;Dual Numbers&lt;/a&gt;.
I will shamelessly refer to &lt;a href=&#34;https://matbesancon.github.io/slides/ad4dev#/12&#34;&gt;my slides&lt;/a&gt;
at the Lambda Lille meetup for an example implementation in Haskell.&lt;/p&gt;
&lt;h1 id=&#34;why-not-reverse-mode&#34;&gt;Why not reverse-mode?&lt;/h1&gt;
&lt;p&gt;I mentioned that the cost of computing the value &amp;amp; derivatives is proportional
to the size of the input, which can increase rapidly for real-world problems.
This is specific to so-called &lt;em&gt;forward mode&lt;/em&gt; automatic differentiation.
We will not go over the inner details of forward versus reverse.
As a rule of thumb, forward-mode has less overhead, and is better when the
dimension of the output far exceeds the dimension of the input, while
reverse-mode is better when the dimension of the input exceeds the one
of the output.&lt;/p&gt;
&lt;h2 id=&#34;giving-reverse-with-zygote-a-shot&#34;&gt;Giving reverse with Zygote a shot&lt;/h2&gt;
&lt;p&gt;Getting back to our question, the answer is rather down-to-earth,
the reverse-mode I tried simply did not work there.
Reverse-mode requires tracing the normal function call, building a
&amp;ldquo;tape&amp;rdquo;, this means that it needs a representation of the function
(as a graph or other).
I gave &lt;a href=&#34;https://github.com/FluxML/Zygote.jl&#34;&gt;Zygote.jl&lt;/a&gt;
a try, which can be done by replacing &lt;code&gt;ForwardDiff.gradient(f,x)&lt;/code&gt; with
&lt;code&gt;Zygote.gradient(f, x)&lt;/code&gt; in the snippet above.
Building a representation of the function means &lt;em&gt;Zygote&lt;/em&gt; must have a
representation of all operations performed. For the moment,
this is still restricted to a subset of the Julia language
(which is far more complex than commonly encountered mathematical functions
built as a single expression). This subset still excludes throwing and
handling exceptions, which is quite present in both ConstraintSolver.jl
and MathOptInterface.&lt;/p&gt;
&lt;p&gt;I have not tried the other reverse tools for the sake of conciseness (and time),
so feel free to check out &lt;a href=&#34;https://github.com/invenia/Nabla.jl&#34;&gt;Nabla.jl&lt;/a&gt;,
&lt;a href=&#34;https://github.com/JuliaDiff/ReverseDiff.jl&#34;&gt;ReverseDiff.jl&lt;/a&gt;
and &lt;a href=&#34;https://github.com/FluxML/Tracker.jl&#34;&gt;Tracker.jl&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;how-could-this-be-improved&#34;&gt;How could this be improved?&lt;/h2&gt;
&lt;p&gt;A first solution could be to move the idiom of Julia from &lt;code&gt;throw/try/catch&lt;/code&gt;
to handling errors as values, using something like the &lt;code&gt;Result/Either&lt;/code&gt; type
in Scala / Haskell / Rust and &lt;a href=&#34;https://github.com/iamed2/ResultTypes.jl&#34;&gt;corresponding libraries&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Another alternative, currently happening is to keep pushing Zygote to support
more features from Julia, going in the direction of supporting differentiation
of any program, as dynamic as it gets.&lt;/p&gt;
&lt;p&gt;One last option for the particular problem of exception handling would be
to be able to opt-out of input validation, with some &lt;code&gt;@validate expr&lt;/code&gt;,
with &lt;code&gt;expr&lt;/code&gt; potentially throwing or handling an error, and a &lt;code&gt;@nocheck&lt;/code&gt;
or &lt;code&gt;@nothrows&lt;/code&gt; macro in front of the function call, considering the function
will remain on the happy path and not guaranteeing validity or error messages
otherwise. This works exactly like the &lt;code&gt;@boundscheck&lt;/code&gt;, &lt;code&gt;@inbounds&lt;/code&gt; pair for
index validation.&lt;/p&gt;
&lt;h1 id=&#34;conclusion-speculation-prospect&#34;&gt;Conclusion, speculation, prospect&lt;/h1&gt;
&lt;p&gt;This post is already too long so we&amp;rsquo;ll stop there.
The biggest highlights here are that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In discrete problems, we also have some continuous parts.&lt;/li&gt;
&lt;li&gt;Julia&amp;rsquo;s type system allows AD to work almost out of the box in most cases.&lt;/li&gt;
&lt;li&gt;With JuMP and MOI, solving optimization problems is just another algorithmic building block in your Julia program, spitting out results, and derivatives if you make them.&lt;/li&gt;
&lt;li&gt;I believe that&amp;rsquo;s why plugging in solvers developed in C/C++ is fine, but not always what we want. I would be ready to take a performance hit on the computation time of my algorithms to have some hackable, type-generic MILP solver in pure Julia.&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;special-mentions&#34;&gt;Special mentions&lt;/h2&gt;
&lt;p&gt;Thanks a lot to &lt;a href=&#34;https://github.com/Wikunia/&#34;&gt;Wikunia&lt;/a&gt;, first for developing ConstraintSolver.jl,
without which none of this would have been possible, and for the open discussion on the multiple
issues I posted. Don&amp;rsquo;t hesitate to check out his &lt;a href=&#34;https://opensourc.es/blog/constraint-solver-1&#34;&gt;blog&lt;/a&gt;,
where the whole journey from 0 to a constraint solver is documented.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;http://conal.net/papers/essence-of-ad/&#34;&gt;The simple essence of automatic differentiation&lt;/a&gt;, Conal Elliott, Proceedings of the ACM on Programming Languages (ICFP), 2018 &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;I believe a pure-Julia solver could be made as fast as a C/C++ solver, but developing solvers is an enormous amount of work and micro-optimizations, tests on industrial cases. The new &lt;a href=&#34;https://highs.dev&#34;&gt;HiGHS&lt;/a&gt; solver however shows that one can get pretty good results by developing a linear solver from scratch with all modern techniques already baked in. &lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>
